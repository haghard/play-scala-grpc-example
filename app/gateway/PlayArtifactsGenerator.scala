package gateway

import com.google.api.HttpRule
import com.google.api.HttpRule.Pattern
import org.reflections.Reflections

import java.io.{File, FileOutputStream}
import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Paths}
import java.util.stream.Collectors
import scala.jdk.CollectionConverters.CollectionHasAsScala
import scala.util.Using
import scala.util.control.NonFatal

object PlayArtifactsGenerator extends App with PlayControllerScaffolding with PlayRoutesScaffolding {
  val SEP = "#"
  val routesFileName = "routes"
  val Pref = "Service"
  val Postfix = "Controller"
  val JavaPackageTag = "java_package"
  val PackageTag = "package"

  val PackageExp = """package(.*)""".r
  val JavaPackageExp = s"""option(.*)${JavaPackageTag}(.*)=(.*)""".r
  val HttpOptionExp = """(\d*):(.*)""".r

  //validate a URL path with no query params (e.g. /helloworld, /hello/world )
  val PathWithNoQueryParams = """^\/[/.a-zA-Z0-9-]+$""".r

  // get: /v1/{name=messages/*}
  val PathParamKVExp = """(.+)\{(.+)=(.+)\}""".r

  /**
   *
   * (e.g. /v1/messages/{name}, /v1/messages/{name}/age/{age}
   */
  val PathParamsExp = """\{(.*?)}""".r


  //https://www.geeksforgeeks.org/check-if-an-url-is-valid-or-not-using-regular-expression/
  val UrlExp = "((http|https)://)(www.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%._\\+~#?&//=]*)"

  val EmptyMessage = com.google.protobuf.Empty.getDescriptor.getFullName

  //google.protobuf.MethodOptions { HttpRule http = 72295728; }
  val HttpRuleHttp = 72295728

  //We rely on a simple fact that all generate gRPC services extend from `akka.grpc.ServiceDescription`.
  //Looks like it's a stable invariant.
  val sdClass = classOf[akka.grpc.ServiceDescription]

  //Support only primitives (non-message) type
  val supportedTypes = Set(classOf[String].getSimpleName, classOf[Int].getSimpleName, classOf[Long].getSimpleName,
    classOf[Boolean].getSimpleName, classOf[Double].getSimpleName)

  def asPlayType(protoType: String): String =
    protoType.charAt(0).toUpper.toString + protoType.substring(1)

  try {
    val paths = args(0).split(SEP)
    val protobufDir = Paths.get(paths(1)).toFile
    val appDir = Paths.get(paths(2))
    val confDir = Paths.get(paths(3))
    val protoFiles = protobufDir.listFiles((_: File, name: String) => name.endsWith(".proto"))
    val targetControllersPackName = paths(4)

    val maybePackageName: Option[String] =
      if (protoFiles.size == 1) {
        val schemaFile = protoFiles(0)
        println(s"★ ★ ★ Protobuf schema file: ${schemaFile.getAbsolutePath} ★ ★ ★")
        val javaPackages =
          Using.resource(java.nio.file.Files.newBufferedReader(schemaFile.toPath)) { in =>
            in.lines().filter { line => !line.contains("""//""") && (line.contains(JavaPackageTag) || line.startsWith(PackageTag)) }
              .collect(Collectors.toList[String])
          }.asScala.toList

        val javaPackagesLine = javaPackages match {
          case List(line) => line
          case List(left, right) =>
            println(""" "option java_package" takes precedence over "package" """)
            if (left.contains(JavaPackageTag)) left else right
          case _ => throw new Exception("Smth's wrong with protobuf package definition")
        }

        val packageName = javaPackagesLine match {
          case JavaPackageExp(_, _, name) => name.replace("\"", "").replace(";", "").trim
          case PackageExp(name) => name.replace("\"", "").replace(";", "").trim
          case _ => throw new Exception("Failed to extract package name.")
        }
        Some(packageName)
      } else None

    val packageName = maybePackageName.getOrElse(throw new Exception("Failed to load package name."))
    println(s"★ ★ ★ PackageName: $packageName ★ ★ ★")

    // All generated by Akka gRPC services
    val reflection = new Reflections(packageName)
    val grpcServicesClasses = reflection.getSubTypesOf(sdClass).asScala

    //We take just one for the time being
    val grpcServiceClass = grpcServicesClasses.headOption.getOrElse(throw new Exception("Failed to load service"))
    println(s"★ ★ ★ Found gRPC service ${grpcServiceClass.getName} ★ ★ ★")

    val serviceName = grpcServiceClass.getSimpleName.replace("$", "")
    val controllerName = s"$serviceName$Postfix"

    val controllerFile = s"${appDir.toFile.getAbsolutePath}/$targetControllersPackName/$controllerName.scala"
    val routesFile = s"${confDir.toFile.getAbsolutePath}/$routesFileName"

    Files.deleteIfExists(Paths.get(controllerFile))
    Files.deleteIfExists(Paths.get(routesFile))

    val mirror = scala.reflect.runtime.universe.runtimeMirror(grpcServiceClass.getClassLoader)
    val servDesc = mirror.reflectModule(mirror.moduleSymbol(grpcServiceClass))
    val descriptor = servDesc.instance.asInstanceOf[akka.grpc.ServiceDescription].descriptor

    val cBuffer = new StringBuilder()
    cBuffer.append(controllerHeader(targetControllersPackName, packageName, controllerName))

    val rBuffer = new StringBuilder()
    rBuffer.append(routesHeader())

    val servicesIt = descriptor.getServices.iterator()

    //we support just one service for the time being
    if (servicesIt.hasNext) {
      val sd = servicesIt.next()

      sd.getMethods.forEach { serviceMethod =>
        val methodOps: com.google.protobuf.DescriptorProtos.MethodOptions = serviceMethod.getOptions()

        //There is no way to parse `HttpRule` from `MethodOptions` so I had to do it manually.
        val httpRuleStr = methodOps.toString.replace(s"$HttpRuleHttp:", "").split("\n")

        var httpRule = HttpRule.defaultInstance
        (1 to httpRuleStr.size - 2).foreach { i =>
          httpRuleStr(i).trim match {
            case HttpOptionExp(ind, value0) =>
              val value = value0.replaceAll("\"", "")
              ind.trim.toInt match {
                case HttpRule.SELECTOR_FIELD_NUMBER => httpRule = httpRule.withSelector(value)
                case HttpRule.GET_FIELD_NUMBER => httpRule = httpRule.withGet(value)
                case HttpRule.PUT_FIELD_NUMBER => httpRule = httpRule.withPut(value)
                case HttpRule.POST_FIELD_NUMBER => httpRule = httpRule.withPost(value)
                case HttpRule.DELETE_FIELD_NUMBER => httpRule = httpRule.withDelete(value)
                case HttpRule.PATCH_FIELD_NUMBER => httpRule = httpRule.withPatch(value)
                case HttpRule.BODY_FIELD_NUMBER => httpRule = httpRule.withBody(value)
                case HttpRule.CUSTOM_FIELD_NUMBER => httpRule = httpRule.withCustom(com.google.api.CustomHttpPattern(value))
                case HttpRule.ADDITIONAL_BINDINGS_FIELD_NUMBER => throw new UnsupportedOperationException("ADDITIONAL_BINDINGS_FIELD_NUMBER is not supported")
                case HttpRule.RESPONSE_BODY_FIELD_NUMBER => httpRule = httpRule.withResponseBody(value)
              }
            case _ => throw new Exception("Failed to parse HttpRule")
          }
        }

        httpRule.pattern match {
          case Pattern.Get(path) =>
            println(s"*** GET ${path.trim}")
            val cleanPath = path.trim
            val (pathWithParam, params) =
              cleanPath match {
                //TODO: get rid of this branch maybe
                case PathParamKVExp(segments, k, v) =>
                  val pName = k.trim
                  val pathSegment = v.trim.replace("/*", "")
                  val getPath = s"$segments$pathSegment/:$pName"
                  println(s"*** Found kv GET " + s"$getPath" + " - " + pName)
                  (getPath, Set(pName))
                case _ =>
                  if (PathWithNoQueryParams.matches(cleanPath)) {
                    (cleanPath, Set.empty[String])
                  } else {
                    val matcher = PathParamsExp.pattern.matcher(cleanPath)
                    var params = Set.empty[String]
                    if (matcher.find()) {
                      val param = cleanPath.substring(matcher.start(), matcher.end()).trim.replaceAll("[\\{\\}]", "")
                      //println(s"*** Found pathParam: $param")
                      params = params + param
                      while (matcher.find()) {
                        val param = cleanPath.substring(matcher.start(), matcher.end()).trim.replaceAll("[\\{\\}]", "")
                        //println(s"*** Found pathParam: $param")
                        params = params + param
                      }
                      // /v1/messages/{name}/a/{age}/ -> /v1/messages/:name/a/:age
                      val a = cleanPath.replace("{", ":").replace("}", "")
                      //remove last "/" if found
                      val b = if (a.charAt(a.length - 1) == '/') a.substring(0, a.length - 1) else a
                      (b, params)
                    } else throw new Exception(s"Smth's wrong with url path ($cleanPath) !")
                  }
              }

            serviceMethod.getInputType.getFullName match {
              case EmptyMessage =>
                rBuffer.append(routesGetRoute(targetControllersPackName, controllerName, pathWithParam, serviceMethod.getName))
                cBuffer.append(controllerGetMethod(serviceMethod.getName, serviceMethod.getOutputType.getName))

              case _ =>
                val requestConstructors = Class.forName(serviceMethod.getInputType.getFullName).getConstructors
                val requestCtrParams =
                  requestConstructors.headOption match {
                    case Some(ctr) =>
                      ctr.getParameters().toSet
                        .filterNot(_.getName == "unknownFields") //filter out unknownFields: scalapb.UnknownFieldSet
                        .map { p =>
                          val pType = p.getType.getSimpleName
                          if (supportedTypes.contains(pType)) (p.getName, asPlayType(pType))
                          else throw new Exception(s"Found unsupported type $pType in ${serviceMethod.getInputType.getFullName}.${p.getName}")
                        }
                        .toMap
                    case None =>
                      throw new Exception(s"${serviceMethod.getInputType.getFullName} should have one constructor")
                  }

                val pathParametersWithTyped =
                  params.foldLeft(Map.empty[String, String]) { (acc, param) =>
                    requestCtrParams.get(param) match {
                      case Some(methodType) =>
                        acc + (param -> methodType)
                      case None =>
                        throw new Exception(s"Couldn't find method ($param) on ${serviceMethod.getInputType.getFullName}. Check your proto schema!")
                    }
                  }

                // Any fields in the request message which are not bound by the path template automatically become HTTP query parameters
                // if there is no HTTP request body !!!!
                val queryParameters = requestCtrParams.keySet.diff(pathParametersWithTyped.keySet)
                val queryParametersWithTypes = queryParameters.map(p => p -> requestCtrParams(p)).toMap

                pathParametersWithTyped.foreach { case (p, t) =>
                  println(s"*** Found type param: $p : $t")
                }

                queryParametersWithTypes.foreach { case (p, t) =>
                  println(s"*** Found query param: $p : $t")
                }

                rBuffer.append(routesGetRoute(
                  targetControllersPackName, controllerName, pathWithParam, serviceMethod.getName, pathParametersWithTyped, queryParametersWithTypes))

                cBuffer.append(controllerGetMethod(
                  serviceMethod.getName, serviceMethod.getOutputType.getName, pathParametersWithTyped, queryParametersWithTypes))
            }

          case Pattern.Post(path) =>
            println(s"*** POST ${path.trim}")
            ???

          case Pattern.Patch(path) => ???
            println(s"*** PATCH ${path.trim}")
            ???

          case Pattern.Put(path) =>
            println(s"*** PUT ${path.trim}")
            ???

          case Pattern.Delete(path) => ???

          case Pattern.Custom(path) => ???
          case Pattern.Empty => ???
        }

        //httpRule.body

        println(s"★ ★ ★ Generating $packageName.$controllerName method ${serviceMethod.getName} ★ ★ ★")
      }
    }

    cBuffer.append(controllerFooter())
    rBuffer.append(routesFooter(targetControllersPackName))

    //TODO: consider writing in chunks
    Using.resource(new FileOutputStream(controllerFile))(_.write(cBuffer.toString().getBytes(StandardCharsets.UTF_8)))
    Using.resource(new FileOutputStream(routesFile))(_.write(rBuffer.toString().getBytes(StandardCharsets.UTF_8)))

  } catch {
    case NonFatal(ex) =>
      println(s"Critical error during Play artifacts generation: ${ex.getMessage}")
      System.exit(-1)
  }
}