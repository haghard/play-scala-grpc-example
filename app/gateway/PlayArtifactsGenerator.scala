package gateway

import org.reflections.Reflections
import org.reflections.util.ConfigurationBuilder

import java.io.{File, FileOutputStream}
import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Paths}
import java.util.stream.Collectors
import scala.jdk.CollectionConverters.CollectionHasAsScala
import scala.util.Using
import scala.util.control.NonFatal

/**
 *
 *
 */
object PlayArtifactsGenerator extends App with PlayControllerScaffolding with PlayRoutesScaffolding {
  val SEP = "#"
  val routesFileName = "routes"
  val Pref = "Service"
  val Postfix = "Controller"
  val JavaPackageTag = "java_package"
  val PackageTag = "package"

  val PackageExp = """package(.*)""".r
  val JavaPackageExp = s"""option(.*)${JavaPackageTag}(.*)=(.*)""".r

  //We rely on a simple fact that all generate gRPC services extend from `akka.grpc.ServiceDescription`.
  //Looks like it's a stable invariant.
  val sdClass = classOf[akka.grpc.ServiceDescription]

  //println(s"""★ ★ ★ Main: ${args.mkString(",")} ★ ★ ★""")
  try {
    val paths = args(0).split(SEP)
    val protobufDir = Paths.get(paths(1)).toFile
    val appDir = Paths.get(paths(2))
    val confDir = Paths.get(paths(3))
    val protoFiles = protobufDir.listFiles((_: File, name: String) => name.endsWith(".proto"))
    val targetControllersPackName = paths(4)

    val maybePackageName: Option[String] =
      if (protoFiles.size == 1) {
        val schemaFile = protoFiles(0)
        println(s"★ ★ ★ Protobuf schema file: ${schemaFile.getAbsolutePath} ★ ★ ★")
        val javaPackages =
          Using.resource(java.nio.file.Files.newBufferedReader(schemaFile.toPath)) { in =>
            in.lines().filter { line => !line.contains("""//""") && (line.contains(JavaPackageTag) || line.startsWith(PackageTag)) }
              .collect(Collectors.toList[String])
          }.asScala.toSeq

        val javaPackagesLine = javaPackages.size match {
          case 1 =>
            javaPackages.head
          case 2 =>
            val a = javaPackages.head
            val b = javaPackages.tail.head
            println(""" "option java_package" takes precedence over "package" """)
            if (a.contains(JavaPackageTag)) a else b
          case _ =>
            throw new Exception("Smth's wrong with protobuf package definition")
        }
        val packageName = javaPackagesLine match {
          case JavaPackageExp(_, _, name) => name.replace("\"", "").replace(";", "").trim
          case PackageExp(name) => name.replace("\"", "").replace(";", "").trim
          case _ => throw new Exception("Failed to extract package name.")
        }
        Some(packageName)

      } else None

    val packageName = maybePackageName.getOrElse(throw new Exception("Failed to load package name."))
    println(s"★ ★ ★ PackageName: $packageName ★ ★ ★")

    // All generated by Akka gRPC services
    val grpcServicesClasses = new Reflections(new ConfigurationBuilder().forPackage(packageName))
      .getSubTypesOf(sdClass).asScala

    //We take just one for the time being
    val grpcServiceClass = grpcServicesClasses.headOption.getOrElse(throw new Exception("Failed to load service"))
    println(s"★ ★ ★ Found gRPC service ${grpcServiceClass.getName} ★ ★ ★")

    val serviceName = grpcServiceClass.getSimpleName.replace("$","")
    val controllerName = s"$serviceName$Postfix"

    val controllerFile = s"${appDir.toFile.getAbsolutePath}/$targetControllersPackName/$controllerName.scala"
    val routesFile = s"${confDir.toFile.getAbsolutePath}/$routesFileName"

    Files.deleteIfExists(Paths.get(controllerFile))
    Files.deleteIfExists(Paths.get(routesFile))

    val mirror = scala.reflect.runtime.universe.runtimeMirror(grpcServiceClass.getClassLoader)
    val servDesc = mirror.reflectModule(mirror.moduleSymbol(grpcServiceClass))
    val descriptor = servDesc.instance.asInstanceOf[akka.grpc.ServiceDescription].descriptor

    val cBuffer = new StringBuilder()
    cBuffer.append(cntrHeader(targetControllersPackName, packageName, controllerName))

    val rBuffer = new StringBuilder()
    rBuffer.append(routesHeader())

    val servicesIt = descriptor.getServices.iterator()

    //we support just one service for the time being
    if (servicesIt.hasNext) {
      val sd = servicesIt.next()
      sd.getMethods.forEach { serviceMethod =>
        cBuffer.append(cntrlMethod(serviceMethod.getName, serviceMethod.getInputType.getName, serviceMethod.getOutputType.getName))
        rBuffer.append(routesRoute(targetControllersPackName, controllerName, serviceMethod.getName))
        println(s"★ ★ ★ Generating $packageName.$controllerName method ${serviceMethod.getName} ★ ★ ★")
      }
    }

    cBuffer.append(cntrFooter())
    rBuffer.append(routesFooter(targetControllersPackName))

    //TODO: consider writing in chunks
    Using.resource(new FileOutputStream(controllerFile))(_.write(cBuffer.toString().getBytes(StandardCharsets.UTF_8)))
    Using.resource(new FileOutputStream(routesFile))(_.write(rBuffer.toString().getBytes(StandardCharsets.UTF_8)))

  } catch {
    case NonFatal(ex) =>
      println(s"Critical error: ${ex.getMessage}")
      System.exit(-1)
  }
}