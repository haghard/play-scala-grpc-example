package gateway

import com.google.api.HttpRule
import com.google.api.HttpRule.Pattern
import org.reflections.Reflections

import java.io.{File, FileOutputStream}
import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Paths}
import java.util.stream.Collectors
import scala.jdk.CollectionConverters.CollectionHasAsScala
import scala.util.Using
import scala.util.control.NonFatal

object PlayArtifactsGenerator extends App with PlayControllerScaffolding with PlayRoutesScaffolding {
  val SEP = "#"
  val routesFileName = "routes"
  val Pref = "Service"
  val Postfix = "Controller"
  val JavaPackageTag = "java_package"
  val PackageTag = "package"

  val PackageExp = """package(.*)""".r
  val JavaPackageExp = s"""option(.*)${JavaPackageTag}(.*)=(.*)""".r
  val HttpOptionExp = """(\d*):(.*)""".r

  // get: /v1/{name=messages/*}
  val PathParamKVExp = """(.+)\{(.+)=(.+)\}""".r

  /*
   * get: /v1/messages/{name}
   * get: /v1/messages/{name}/age/{age}
   */
  val PathParamsExp = """\{(.*?)}""".r

  //google.protobuf.MethodOptions { HttpRule http = 72295728; }
  val HttpRuleHttp = 72295728

  //We rely on a simple fact that all generate gRPC services extend from `akka.grpc.ServiceDescription`.
  //Looks like it's a stable invariant.
  val sdClass = classOf[akka.grpc.ServiceDescription]

  def asScalaType(protoType: String): String =
    protoType.charAt(0).toUpper.toString + protoType.substring(1)

  try {
    val paths = args(0).split(SEP)
    val protobufDir = Paths.get(paths(1)).toFile
    val appDir = Paths.get(paths(2))
    val confDir = Paths.get(paths(3))
    val protoFiles = protobufDir.listFiles((_: File, name: String) => name.endsWith(".proto"))
    val targetControllersPackName = paths(4)

    val maybePackageName: Option[String] =
      if (protoFiles.size == 1) {
        val schemaFile = protoFiles(0)
        println(s"★ ★ ★ Protobuf schema file: ${schemaFile.getAbsolutePath} ★ ★ ★")
        val javaPackages =
          Using.resource(java.nio.file.Files.newBufferedReader(schemaFile.toPath)) { in =>
            in.lines().filter { line => !line.contains("""//""") && (line.contains(JavaPackageTag) || line.startsWith(PackageTag)) }
              .collect(Collectors.toList[String])
          }.asScala.toList

        val javaPackagesLine = javaPackages match {
          case List(line) => line
          case List(left, right) =>
            println(""" "option java_package" takes precedence over "package" """)
            if (left.contains(JavaPackageTag)) left else right
          case _ => throw new Exception("Smth's wrong with protobuf package definition")
        }

        val packageName = javaPackagesLine match {
          case JavaPackageExp(_, _, name) => name.replace("\"", "").replace(";", "").trim
          case PackageExp(name) => name.replace("\"", "").replace(";", "").trim
          case _ => throw new Exception("Failed to extract package name.")
        }
        Some(packageName)
      } else None

    val packageName = maybePackageName.getOrElse(throw new Exception("Failed to load package name."))
    println(s"★ ★ ★ PackageName: $packageName ★ ★ ★")

    // All generated by Akka gRPC services
    val reflection = new Reflections(packageName)
    val grpcServicesClasses = reflection.getSubTypesOf(sdClass).asScala

    //We take just one for the time being
    val grpcServiceClass = grpcServicesClasses.headOption.getOrElse(throw new Exception("Failed to load service"))
    println(s"★ ★ ★ Found gRPC service ${grpcServiceClass.getName} ★ ★ ★")

    val serviceName = grpcServiceClass.getSimpleName.replace("$", "")
    val controllerName = s"$serviceName$Postfix"

    val controllerFile = s"${appDir.toFile.getAbsolutePath}/$targetControllersPackName/$controllerName.scala"
    val routesFile = s"${confDir.toFile.getAbsolutePath}/$routesFileName"

    Files.deleteIfExists(Paths.get(controllerFile))
    Files.deleteIfExists(Paths.get(routesFile))

    val mirror = scala.reflect.runtime.universe.runtimeMirror(grpcServiceClass.getClassLoader)
    val servDesc = mirror.reflectModule(mirror.moduleSymbol(grpcServiceClass))
    val descriptor = servDesc.instance.asInstanceOf[akka.grpc.ServiceDescription].descriptor

    val cBuffer = new StringBuilder()
    cBuffer.append(cntrPostHeader(targetControllersPackName, packageName, controllerName))

    val rBuffer = new StringBuilder()
    rBuffer.append(routesHeader())

    val servicesIt = descriptor.getServices.iterator()

    //we support just one service for the time being
    if (servicesIt.hasNext) {
      val sd = servicesIt.next()

      sd.getMethods.forEach { serviceMethod =>
        val methodOps: com.google.protobuf.DescriptorProtos.MethodOptions = serviceMethod.getOptions()

        //There is no way to parse `HttpRule` from `MethodOptions` so I had to do it manually.
        val httpRuleStr = methodOps.toString.replace(s"$HttpRuleHttp:", "").split("\n")

        var httpRule = HttpRule.defaultInstance
        (1 to httpRuleStr.size - 2).foreach { i =>
          httpRuleStr(i).trim match {
            case HttpOptionExp(ind, value0) =>
              val value = value0.replaceAll("\"", "")
              ind.trim.toInt match {
                case HttpRule.SELECTOR_FIELD_NUMBER => httpRule = httpRule.withSelector(value)
                case HttpRule.GET_FIELD_NUMBER => httpRule = httpRule.withGet(value)
                case HttpRule.PUT_FIELD_NUMBER => httpRule = httpRule.withPut(value)
                case HttpRule.POST_FIELD_NUMBER => httpRule = httpRule.withPost(value)
                case HttpRule.DELETE_FIELD_NUMBER => httpRule = httpRule.withDelete(value)
                case HttpRule.PATCH_FIELD_NUMBER => httpRule = httpRule.withPatch(value)
                case HttpRule.BODY_FIELD_NUMBER => httpRule = httpRule.withBody(value)
                case HttpRule.CUSTOM_FIELD_NUMBER => httpRule = httpRule.withCustom(com.google.api.CustomHttpPattern(value))
                case HttpRule.ADDITIONAL_BINDINGS_FIELD_NUMBER => throw new UnsupportedOperationException("ADDITIONAL_BINDINGS_FIELD_NUMBER is not supported")
                case HttpRule.RESPONSE_BODY_FIELD_NUMBER => httpRule = httpRule.withResponseBody(value)
              }
            case _ => throw new Exception("Failed to parse HttpRule")
          }
        }

        httpRule.pattern match {
          case Pattern.Get(path) =>
            println(s"*** GET ${path.trim}")
            val (pathWithParam, params) =
              path.trim match {
                //TODO: get rid of this branch
                case PathParamKVExp(segments, k, v) =>
                  val pName = k.trim
                  val pathSegment = v.trim.replace("/*", "")
                  val getPath = s"$segments$pathSegment/:$pName"
                  println(s"*** Found kv GET " + s"$getPath" + " - " + pName)
                  (getPath, Set(pName))
                case _ =>
                  val matcher = PathParamsExp.pattern.matcher(path)
                  var params = Set.empty[String]
                  if (matcher.find()) {
                    val param = path.substring(matcher.start(), matcher.end()).trim.replaceAll("[\\{\\}]", "")
                    println(s"*** Found pathParam: $param")
                    params = params + param
                    while (matcher.find()) {
                      val param = path.substring(matcher.start(), matcher.end()).trim.replaceAll("[\\{\\}]", "")
                      println(s"*** Found pathParam: $param")
                      params = params + param
                    }
                    // /v1/messages/{name}/a/{age} -> /v1/messages/:name/a/:age
                    (path.replace("{", ":").replace("}", ""), params)
                  } else throw new Exception(s"Smth's wrong with $path !")
              }

            val requestConstructors = Class.forName(serviceMethod.getInputType.getFullName).getConstructors
            val requestCtrParams =
              requestConstructors.headOption match {
                case Some(ctr) =>
                  ctr.getParameters().toSet
                    .filterNot(_.getName == "unknownFields") //filter out unknownFields: scalapb.UnknownFieldSet
                    .map { p => (p.getName, asScalaType(p.getType.getSimpleName)) }
                    .toMap
                case None =>
                  throw new Exception(s"${serviceMethod.getInputType.getFullName} should have one constructor")
              }

            val pathParametersWithTyped =
              params.foldLeft(Map.empty[String, String]) { (acc, param) =>
                requestCtrParams.get(param) match {
                  case Some(methodType) =>
                    acc + (param -> methodType)
                  case None =>
                    throw new Exception(s"Couldn't find method ($param) on ${serviceMethod.getInputType.getFullName}. Check your proto schema!")
                }
              }

            // Any fields in the request message which are not bound by the path template automatically become HTTP query parameters
            // if there is no HTTP request body !!!!
            val queryParameters = requestCtrParams.keySet.diff(pathParametersWithTyped.keySet)
            val queryParametersWithTypes = queryParameters.map(p => p -> requestCtrParams(p)).toMap

            rBuffer.append(routesGetRoute(
              targetControllersPackName, controllerName, pathWithParam, serviceMethod.getName, pathParametersWithTyped, queryParametersWithTypes))

            cBuffer.append(cntrlGetMethod(
              serviceMethod.getName, pathParametersWithTyped, queryParametersWithTypes, serviceMethod.getOutputType.getName))

          case Pattern.Post(path) =>
            ???

          case Pattern.Put(path) => ???
          case Pattern.Delete(path) => ???
          case Pattern.Patch(path) => ???
          case Pattern.Custom(path) => ???
          case Pattern.Empty => ???
        }

        //httpRule.body

        println(s"★ ★ ★ Generating $packageName.$controllerName method ${serviceMethod.getName} ★ ★ ★")
      }
    }

    cBuffer.append(cntrFooter())
    rBuffer.append(routesFooter(targetControllersPackName))

    //TODO: consider writing in chunks
    Using.resource(new FileOutputStream(controllerFile))(_.write(cBuffer.toString().getBytes(StandardCharsets.UTF_8)))
    Using.resource(new FileOutputStream(routesFile))(_.write(rBuffer.toString().getBytes(StandardCharsets.UTF_8)))

  } catch {
    case NonFatal(ex) =>
      println(s"Critical error during Play artifacts generation: ${ex.getMessage}")
      System.exit(-1)
  }
}