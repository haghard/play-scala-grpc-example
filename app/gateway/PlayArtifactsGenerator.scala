package gateway

import com.google.api.HttpRule
import org.reflections.Reflections
import org.reflections.util.ConfigurationBuilder

import java.io.{File, FileOutputStream}
import java.nio.charset.StandardCharsets
import java.nio.file.{Files, Paths}
import java.util.stream.Collectors
import scala.jdk.CollectionConverters.CollectionHasAsScala
import scala.util.Using
import scala.util.control.NonFatal

object PlayArtifactsGenerator extends App with PlayControllerScaffolding with PlayRoutesScaffolding {
  val SEP = "#"
  val routesFileName = "routes"
  val Pref = "Service"
  val Postfix = "Controller"
  val JavaPackageTag = "java_package"
  val PackageTag = "package"

  val PackageExp = """package(.*)""".r
  val JavaPackageExp = s"""option(.*)${JavaPackageTag}(.*)=(.*)""".r

  val HttpOptionExp = """(\d*):(.*)""".r

  //google.protobuf.MethodOptions { HttpRule http = 72295728; }
  val HttpRuleHttp = 72295728

  //We rely on a simple fact that all generate gRPC services extend from `akka.grpc.ServiceDescription`.
  //Looks like it's a stable invariant.
  val sdClass = classOf[akka.grpc.ServiceDescription]

  try {
    val paths = args(0).split(SEP)
    val protobufDir = Paths.get(paths(1)).toFile
    val appDir = Paths.get(paths(2))
    val confDir = Paths.get(paths(3))
    val protoFiles = protobufDir.listFiles((_: File, name: String) => name.endsWith(".proto"))
    val targetControllersPackName = paths(4)

    val maybePackageName: Option[String] =
      if (protoFiles.size == 1) {
        val schemaFile = protoFiles(0)
        println(s"★ ★ ★ Protobuf schema file: ${schemaFile.getAbsolutePath} ★ ★ ★")
        val javaPackages =
          Using.resource(java.nio.file.Files.newBufferedReader(schemaFile.toPath)) { in =>
            in.lines().filter { line => !line.contains("""//""") && (line.contains(JavaPackageTag) || line.startsWith(PackageTag)) }
              .collect(Collectors.toList[String])
          }.asScala.toSeq

        val javaPackagesLine = javaPackages.size match {
          case 1 =>
            javaPackages.head
          case 2 =>
            val a = javaPackages.head
            val b = javaPackages.tail.head
            println(""" "option java_package" takes precedence over "package" """)
            if (a.contains(JavaPackageTag)) a else b
          case _ =>
            throw new Exception("Smth's wrong with protobuf package definition")
        }
        val packageName = javaPackagesLine match {
          case JavaPackageExp(_, _, name) => name.replace("\"", "").replace(";", "").trim
          case PackageExp(name) => name.replace("\"", "").replace(";", "").trim
          case _ => throw new Exception("Failed to extract package name.")
        }
        Some(packageName)

      } else None

    val packageName = maybePackageName.getOrElse(throw new Exception("Failed to load package name."))
    println(s"★ ★ ★ PackageName: $packageName ★ ★ ★")

    // All generated by Akka gRPC services
    val grpcServicesClasses = new Reflections(new ConfigurationBuilder().forPackage(packageName))
      .getSubTypesOf(sdClass).asScala

    //We take just one for the time being
    val grpcServiceClass = grpcServicesClasses.headOption.getOrElse(throw new Exception("Failed to load service"))
    println(s"★ ★ ★ Found gRPC service ${grpcServiceClass.getName} ★ ★ ★")

    val serviceName = grpcServiceClass.getSimpleName.replace("$", "")
    val controllerName = s"$serviceName$Postfix"

    val controllerFile = s"${appDir.toFile.getAbsolutePath}/$targetControllersPackName/$controllerName.scala"
    val routesFile = s"${confDir.toFile.getAbsolutePath}/$routesFileName"

    Files.deleteIfExists(Paths.get(controllerFile))
    Files.deleteIfExists(Paths.get(routesFile))

    val mirror = scala.reflect.runtime.universe.runtimeMirror(grpcServiceClass.getClassLoader)
    val servDesc = mirror.reflectModule(mirror.moduleSymbol(grpcServiceClass))
    val descriptor = servDesc.instance.asInstanceOf[akka.grpc.ServiceDescription].descriptor

    val cBuffer = new StringBuilder()
    cBuffer.append(cntrHeader(targetControllersPackName, packageName, controllerName))

    val rBuffer = new StringBuilder()
    rBuffer.append(routesHeader())

    val servicesIt = descriptor.getServices.iterator()

    //we support just one service for the time being
    if (servicesIt.hasNext) {
      val sd = servicesIt.next()

      sd.getMethods.forEach { serviceMethod =>
        val methodOps: com.google.protobuf.DescriptorProtos.MethodOptions = serviceMethod.getOptions()

        //There is no way to parse `HttpRule` from `MethodOptions` so I have to do it manually
        val kvs = methodOps.toString.replace(HttpRuleHttp.toString + ":", "").split("\n")

        var httpRule = HttpRule.defaultInstance
        (1 to kvs.size - 2).foreach { i =>
          kvs(i).trim match {
            case HttpOptionExp(ind, value) =>
              val v = value.replaceAll("\"", "")
              HttpRule.scalaDescriptor.fields(ind.trim.toInt).index match {
                case 1 => httpRule = httpRule.withSelector(v)
                case 2 => httpRule = httpRule.withGet(v)
                case 3 => httpRule = httpRule.withPut(v)
                case 4 => httpRule = httpRule.withPost(v)
                case 5 => httpRule = httpRule.withDelete(v)
                case 6 => httpRule = httpRule.withPatch(v)
                case 7 => httpRule = httpRule.withBody(v)
                case 8 => httpRule.withCustom(com.google.api.CustomHttpPattern(v))
                case 12 => httpRule.withResponseBody(v)
              }
            case _ => throw new Exception("Failed to parse HttpRule")
          }
        }

        println(httpRule)

        /*httpRule.pattern match {
          case Pattern.Get(value) => ???
          case Pattern.Put(value) => ???
          case Pattern.Post(value) => ???
          case Pattern.Delete(value) => ???
          case Pattern.Patch(value) => ???
          case Pattern.Custom(value) => ???
          case Pattern.Empty => ???
        }*/

        httpRule.body


        cBuffer.append(cntrlMethod(serviceMethod.getName, serviceMethod.getInputType.getName, serviceMethod.getOutputType.getName))
        rBuffer.append(routesRoute(targetControllersPackName, controllerName, serviceMethod.getName))
        println(s"★ ★ ★ Generating $packageName.$controllerName method ${serviceMethod.getName} ★ ★ ★")
      }
    }

    cBuffer.append(cntrFooter())
    rBuffer.append(routesFooter(targetControllersPackName))

    //TODO: consider writing in chunks
    Using.resource(new FileOutputStream(controllerFile))(_.write(cBuffer.toString().getBytes(StandardCharsets.UTF_8)))
    Using.resource(new FileOutputStream(routesFile))(_.write(rBuffer.toString().getBytes(StandardCharsets.UTF_8)))

  } catch {
    case NonFatal(ex) =>
      println(s"Critical error: ${ex.getMessage}")
      System.exit(-1)
  }
}